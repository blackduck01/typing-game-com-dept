    <script>
        // 사람 데이터 (총 19명: 나쨩 + 스태프2 + 참가자16)
        let people = [
            // 1. 호스트
            { id: 1, name: "나쨩", role: "host", color: "bg-black", prev: 0 }, 
            
            // 2. 스태프
            { id: 2, name: "스텝1", role: "staff", color: "bg-black", prev: 0 },
            { id: 3, name: "스텝2", role: "staff", color: "bg-black", prev: 0 },

            // 3. 참가자 16명
            { id: 4, name: "참가1", role: "blue", color: "bg-blue", prev: 0 },
            { id: 5, name: "참가2", role: "green", color: "bg-green", prev: 0 },
            { id: 6, name: "참가3", role: "orange", color: "bg-orange", prev: 0 },
            { id: 7, name: "참가4", role: "red", color: "bg-red", prev: 0 },
            
            { id: 8, name: "참가5", role: "blue", color: "bg-blue", prev: 0 },
            { id: 9, name: "참가6", role: "green", color: "bg-green", prev: 0 },
            { id: 10, name: "참가7", role: "orange", color: "bg-orange", prev: 0 },
            { id: 11, name: "참가8", role: "red", color: "bg-red", prev: 0 },
            
            { id: 12, name: "참가9", role: "blue", color: "bg-blue", prev: 0 },
            { id: 13, name: "참가10", role: "green", color: "bg-green", prev: 0 },
            { id: 14, name: "참가11", role: "orange", color: "bg-orange", prev: 0 },
            { id: 15, name: "참가12", role: "red", color: "bg-red", prev: 0 },
            
            { id: 16, name: "참가13", role: "blue", color: "bg-blue", prev: 0 },
            { id: 17, name: "참가14", role: "green", color: "bg-green", prev: 0 }, 
            { id: 18, name: "참가15", role: "orange", color: "bg-orange", prev: 0 },
            { id: 19, name: "참가16", role: "red", color: "bg-red", prev: 0 } 
        ];

        // 1부 배치
        function setPhase1() {
            clearTables();
            // 1조 (나쨩 + 4명)
            assignRender(people[0], 1); assignRender(people[3], 1); assignRender(people[4], 1); assignRender(people[5], 1); assignRender(people[6], 1);
            // 2조 (스텝1 + 4명)
            assignRender(people[1], 2); assignRender(people[7], 2); assignRender(people[8], 2); assignRender(people[9], 2); assignRender(people[10], 2);
            // 3조 (스텝2 + 4명)
            assignRender(people[2], 3); assignRender(people[11], 3); assignRender(people[12], 3); assignRender(people[13], 3); assignRender(people[14], 3);
            // 4조 (4명)
            assignRender(people[15], 4); assignRender(people[16], 4); assignRender(people[17], 4); assignRender(people[18], 4);
        }

        // 화면에 그리기 전용 함수
        function assignRender(person, tableNum) {
            person.prev = tableNum; // 현재 자리 기록
            
            const table = document.getElementById(`table-${tableNum}`);
            const el = document.createElement('div');
            el.className = `person ${person.color}`;
            if (person.role === 'host') el.classList.add('host');
            el.innerHTML = `${person.name}`;

            const currentCount = table.querySelectorAll('.person').length;
            const maxSeats = (tableNum === 4) ? 4 : 5; 
            
            // 자리 배치 각도 계산
            const displayMax = Math.max(currentCount + 1, maxSeats);
            // 360도를 인원수로 나눠서 배치
            const angle = (360 / displayMax) * currentCount - 90; 
            const radius = 85; 

            const x = Math.cos(angle * Math.PI / 180) * radius;
            const y = Math.sin(angle * Math.PI / 180) * radius;
            
            el.style.transform = `translate(${x}px, ${y}px)`;
            table.appendChild(el);
        }

        function clearTables() {
            document.querySelectorAll('.table-group').forEach(el => {
                const center = el.querySelector('.table-center');
                el.innerHTML = '';
                el.appendChild(center);
            });
        }

        // ★★★ 자리 섞기 (재시도 로직 적용) ★★★
        function shuffleSeats(mode) {
            const MAX_RETRIES = 500; // 500번까지 시도해서 완벽한 조합 찾기
            let success = false;
            let finalPlan = []; // 성공한 배치 계획을 담을 곳

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                // 1. 시뮬레이션용 테이블 초기화
                let tempTables = {
                    1: { count: 1, colors: [] }, // 나쨩 자리 확보
                    2: { count: 0, colors: [] },
                    3: { count: 0, colors: [] },
                    4: { count: 0, colors: [] }
                };
                let tempPlan = []; // [ {person:객체, table:번호} ]

                // 2. 나쨩 1조 고정
                tempPlan.push({ person: people[0], table: 1 });

                // 3. 스태프 배치 (랜덤)
                let staff = [people[1], people[2]].sort(() => Math.random() - 0.5);
                
                // 스태프가 갈 수 있는 곳 (2,3,4조 중 하나)
                // 조건: 이전 자리 피하기 시도 (하지만 필수는 아님, 스태프는 자리가 중요해서)
                let staffFail = false;
                for (let st of staff) {
                    let options = [2, 3, 4].filter(t => tempTables[t].count === 0); // 스태프끼리 겹치지 않게 (각 조에 1명씩)
                    
                    // 만약 꽉 찼으면 (3명 이상일 때) 아무데나 빈 곳
                    if (options.length === 0) options = [2, 3, 4].filter(t => tempTables[t].count < 2);
                    
                    if (options.length === 0) { staffFail = true; break; } // 배치 실패

                    // 스태프 배치
                    let target = options[Math.floor(Math.random() * options.length)];
                    tempTables[target].count++;
                    tempTables[target].colors.push('staff');
                    tempPlan.push({ person: st, table: target });
                }
                if (staffFail) continue; // 이번 시도 실패, 재시작

                // 4. 참가자 배치
                let users = people.slice(3).sort(() => Math.random() - 0.5); // 랜덤 셔플
                let userFail = false;

                for (let user of users) {
                    // 들어갈 수 있는 후보 테이블 찾기
                    let candidates = [1, 2, 3, 4].filter(t => {
                        let limit = (t === 4) ? 4 : 5;
                        let hasSpace = tempTables[t].count < limit;
                        
                        // ★핵심: 균등 모드일 때 색깔이 겹치면 후보 탈락!
                        let colorOk = (mode === 'balanced') ? !tempTables[t].colors.includes(user.role) : true;
                        
                        return hasSpace && colorOk;
                    });

                    if (candidates.length === 0) {
                        userFail = true; // 갈 곳이 없음 -> 이번 시도 망함 -> 다시 섞자!
                        break;
                    }

                    // 후보들 중에서 '이전 자리'가 아닌 곳을 우선 선택
                    let bestOptions = candidates.filter(t => t !== user.prev);
                    
                    // 만약 모든 후보가 이전 자리라면? (어쩔 수 없이 앉아야 함) -> candidates 사용
                    // 이전 자리 피할 수 있으면 -> bestOptions 사용
                    let finalOptions = (bestOptions.length > 0) ? bestOptions : candidates;
                    
                    let selectedTable = finalOptions[Math.floor(Math.random() * finalOptions.length)];

                    // 배치 확정 (메모리 상)
                    tempTables[selectedTable].count++;
                    tempTables[selectedTable].colors.push(user.role);
                    tempPlan.push({ person: user, table: selectedTable });
                }

                if (!userFail) {
                    // 모든 참가자가 규칙을 지키며 앉았다!
                    success = true;
                    finalPlan = tempPlan;
                    break; // 루프 종료
                }
            }

            // 결과 적용
            if (success) {
                clearTables();
                finalPlan.forEach(item => {
                    assignRender(item.person, item.table);
                });
            } else {
                alert("⚠️ 조건에 딱 맞는 자리를 찾지 못했어요!\n다시 한 번 버튼을 눌러주세요.");
                // 실패 시 그냥 1부 배치로 돌리거나, 아무것도 안 함
            }
        }

        setPhase1(); // 초기 실행
    </script>
