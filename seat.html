<script>
        // 사람 데이터 (총 19명: 나쨩 + 스태프2 + 참가자16)
        let people = [
            // 1. 호스트 (나쨩도 이제 움직이니까 role을 'black'으로 통일!)
            { id: 1, name: "나쨩", role: "black", color: "bg-black", prev: 0 }, 
            
            // 2. 스태프
            { id: 2, name: "스텝1", role: "black", color: "bg-black", prev: 0 },
            { id: 3, name: "스텝2", role: "black", color: "bg-black", prev: 0 },

            // 3. 참가자 16명
            { id: 4, name: "참가1", role: "blue", color: "bg-blue", prev: 0 },
            { id: 5, name: "참가2", role: "green", color: "bg-green", prev: 0 },
            { id: 6, name: "참가3", role: "orange", color: "bg-orange", prev: 0 },
            { id: 7, name: "참가4", role: "red", color: "bg-red", prev: 0 },
            
            { id: 8, name: "참가5", role: "blue", color: "bg-blue", prev: 0 },
            { id: 9, name: "참가6", role: "green", color: "bg-green", prev: 0 },
            { id: 10, name: "참가7", role: "orange", color: "bg-orange", prev: 0 },
            { id: 11, name: "참가8", role: "red", color: "bg-red", prev: 0 },
            
            { id: 12, name: "참가9", role: "blue", color: "bg-blue", prev: 0 },
            { id: 13, name: "참가10", role: "green", color: "bg-green", prev: 0 },
            { id: 14, name: "참가11", role: "orange", color: "bg-orange", prev: 0 },
            { id: 15, name: "참가12", role: "red", color: "bg-red", prev: 0 },
            
            { id: 16, name: "참가13", role: "blue", color: "bg-blue", prev: 0 },
            { id: 17, name: "참가14", role: "green", color: "bg-green", prev: 0 }, 
            { id: 18, name: "참가15", role: "orange", color: "bg-orange", prev: 0 },
            { id: 19, name: "참가16", role: "red", color: "bg-red", prev: 0 } 
        ];

        // 1부 배치 (초기는 나쨩이 1조에 있는 걸로 시작! 버튼 누르면 섞임)
        function setPhase1() {
            clearTables();
            // 1조 (나쨩 + 4명)
            assignRender(people[0], 1); assignRender(people[3], 1); assignRender(people[4], 1); assignRender(people[5], 1); assignRender(people[6], 1);
            // 2조 (스텝1 + 4명)
            assignRender(people[1], 2); assignRender(people[7], 2); assignRender(people[8], 2); assignRender(people[9], 2); assignRender(people[10], 2);
            // 3조 (스텝2 + 4명)
            assignRender(people[2], 3); assignRender(people[11], 3); assignRender(people[12], 3); assignRender(people[13], 3); assignRender(people[14], 3);
            // 4조 (4명)
            assignRender(people[15], 4); assignRender(people[16], 4); assignRender(people[17], 4); assignRender(people[18], 4);
        }

        function assignRender(person, tableNum) {
            const table = document.getElementById(`table-${tableNum}`);
            const el = document.createElement('div');
            el.className = `person ${person.color}`;
            if (person.id === 1) el.classList.add('host'); 
            el.innerHTML = `${person.name}`;

            const currentCount = table.querySelectorAll('.person').length;
            const maxSeats = (tableNum === 4) ? 4 : 5; 
            
            const displayMax = Math.max(currentCount + 1, maxSeats);
            const angle = (360 / displayMax) * currentCount - 90; 
            const radius = 85; 

            const x = Math.cos(angle * Math.PI / 180) * radius;
            const y = Math.sin(angle * Math.PI / 180) * radius;
            
            el.style.transform = `translate(${x}px, ${y}px)`;
            table.appendChild(el);
        }

        function clearTables() {
            document.querySelectorAll('.table-group').forEach(el => {
                const center = el.querySelector('.table-center');
                el.innerHTML = '';
                el.appendChild(center);
            });
        }

        // ★★★ 자리 섞기 (나쨩 포함 랜덤 섞기!) ★★★
        function shuffleSeats(mode) {
            const MAX_RETRIES = 500;
            let success = false;
            let finalPlan = [];

            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                
                // 1. 테이블 초기화
                let tempTables = {
                    1: { count: 0, colors: [] },
                    2: { count: 0, colors: [] },
                    3: { count: 0, colors: [] },
                    4: { count: 0, colors: [] }
                };
                let tempPlan = []; 

                // 2. 진행팀 배치 (나쨩 + 스텝1 + 스텝2 = 총 3명)
                // 이들을 'black' 역할로 묶어서 서로 다른 테이블에 배치
                let leaders = [people[0], people[1], people[2]].sort(() => Math.random() - 0.5);
                let tableOptions = [1, 2, 3, 4]; // 모든 테이블 가능!

                let leaderFail = false;
                for (let leader of leaders) {
                    // 빈 테이블이면서 & 이전 자리가 아닌 곳 우선
                    // (진행팀은 서로 'black'이므로 색깔 겹침 방지를 위해 빈 테이블만 찾음)
                    let options = tableOptions.filter(t => tempTables[t].count === 0 && t !== leader.prev);
                    
                    // 조건에 맞는 곳 없으면, 그냥 빈 테이블 아무데나
                    if (options.length === 0) {
                        options = tableOptions.filter(t => tempTables[t].count === 0);
                    }

                    if (options.length === 0) { leaderFail = true; break; }

                    let target = options[Math.floor(Math.random() * options.length)];
                    tempTables[target].count++;
                    tempTables[target].colors.push('black'); // 색깔 등록!
                    tempPlan.push({ person: leader, table: target });
                }
                if (leaderFail) continue; // 실패시 재시도

                // 3. 참가자 배치 (나머지 16명)
                let users = people.slice(3).sort(() => Math.random() - 0.5); 
                let userFail = false;

                for (let user of users) {
                    let candidates = [1, 2, 3, 4].filter(t => {
                        let limit = (t === 4) ? 4 : 5;
                        let hasSpace = tempTables[t].count < limit;
                        
                        // 균등 모드면 색깔 체크 (black 포함해서 모든 색 체크됨)
                        let colorOk = (mode === 'balanced') ? !tempTables[t].colors.includes(user.role) : true;
                        
                        return hasSpace && colorOk;
                    });

                    if (candidates.length === 0) { userFail = true; break; }

                    let bestOptions = candidates.filter(t => t !== user.prev);
                    let finalOptions = (bestOptions.length > 0) ? bestOptions : candidates;
                    
                    let selectedTable = finalOptions[Math.floor(Math.random() * finalOptions.length)];

                    tempTables[selectedTable].count++;
                    tempTables[selectedTable].colors.push(user.role);
                    tempPlan.push({ person: user, table: selectedTable });
                }

                if (!userFail) {
                    success = true;
                    finalPlan = tempPlan;
                    break;
                }
            }

            if (success) {
                clearTables();
                finalPlan.forEach(item => {
                    item.person.prev = item.table; // 자리 기록 업데이트
                    assignRender(item.person, item.table);
                });
            } else {
                alert("⚠️ 배치 실패! 다시 시도해주세요.");
            }
        }

        setPhase1(); // 페이지 열리면 초기 상태 보여줌
    </script>